<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Archive: 2019
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;archives&#x2F;2019&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Hexo</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Hexo</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">John Doe</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://cn.gravatar.com/avatar/35fef74d731255cd569c2c2b0b9e87e4?s=200"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">3</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage" external="false">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year" external="false">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="noopener">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/denjones" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS" external="false">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/archives/2019" class="archive-year">2019</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2019/11/10/HTTP%E4%B8%8EHTTPS%E5%8D%8F%E8%AE%AE/" >
  HTTP与HTTPS协议
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2019/11/10/HTTP%E4%B8%8EHTTPS%E5%8D%8F%E8%AE%AE/"><span class="article-date">
  2019-11-10
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <h1 id="HTTP协议与HTTPS协议"><a href="#HTTP协议与HTTPS协议" class="headerlink" title="HTTP协议与HTTPS协议"></a>HTTP协议与HTTPS协议</h1><p>载录：CSDN博客</p>
<p><a href="https://blog.csdn.net/wangtaomtk/article/details/80963029" target="_blank" rel="noopener">https://blog.csdn.net/wangtaomtk/article/details/80963029</a> </p>
<p><a href="https://blog.csdn.net/qq_38289815/article/details/80969419" target="_blank" rel="noopener">https://blog.csdn.net/qq_38289815/article/details/80969419</a></p>
<h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h2><p>①HTTP</p>
<blockquote>
<p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。Http协议是以明文方式发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
</blockquote>
<p>协议：是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。超文本传输协议(HTTP)是一种<strong>通信协议</strong>，它允许将<strong>超文本标记语言(HTML)文档</strong>从Web服务器传送到客户端的浏览器。详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间<strong>互相通信的规则</strong>，通过因特网传送万维网文档的<strong>数据传送协议</strong>。</p>
<p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP是一个<strong>应用层协议</strong>，由请求和响应构成，是一个标准的<strong>客户端服务器模型</strong>。HTTP是一个<strong>无状态</strong>（Web服务器不保存发送请求的Web浏览器进程的任何信息）的协议。</p>
<p>在Internet中所有的传输都是通过<strong>TCP/IP</strong>进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常<strong>承载于TCP协议之上</strong>，<strong>有时也承载于TLS或SSL协议层之上</strong>，这个时候，就成了我们常说的<strong>HTTPS</strong>。（网址就有https：//啥啥啥的）</p>
<p>HTTP默认的端口号为80，HTTPS的端口号为443(端口号是干啥的？)</p>
<p>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，<strong>只要通信的双方都遵守这个协议，HTTP就能有用武之地</strong>。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p>
<p>②HTTPS</p>
<blockquote>
<p>是以安全为目标的HTTPS通道，是Http的安全版。Https的安全基础是<strong>SSL</strong>。</p>
</blockquote>
<p>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：</p>
<p><strong>1)SSL记录协议</strong>（SSL Record Protocol）</p>
<p>它建立在可靠的传输协议（如TCP）之上。为高层协议提供<strong>数据封装、压缩、加密</strong>等基本功能的支持。</p>
<p><strong>2)SSL握手协议</strong>（SSL Handshake Protocol）</p>
<p>它建立在SSL记录协议之上。用于在实际的数据传输开始前，通讯双方进行<strong>身份认证、协商加密算法、交换加密密钥</strong>等。</p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a><strong>二、特点</strong></h2><p><strong>HTTP协议是无状态的和Connection: keep-alive的区别：</strong></p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP/1.1起，默认都开启了<strong>Keep-Alive</strong>，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>
<p>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
<h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><p>①HTTP</p>
<p><img src="https://img-blog.csdn.net/20180719094739178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的运用层协议，所以通信的过程其实是对应数据的入栈和出栈。</p>
<p><img src="https://img-blog.csdn.net/20180719094756330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。</p>
<p><img src="https://img-blog.csdn.net/20180719110828114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="为什么需要三次握手呢？"><a href="#为什么需要三次握手呢？" class="headerlink" title="为什么需要三次握手呢？"></a>为什么需要三次握手呢？</h4><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。</p>
<h4 id="为什么需要四次挥手呢？"><a href="#为什么需要四次挥手呢？" class="headerlink" title="为什么需要四次挥手呢？"></a>为什么需要四次挥手呢？</h4><p>TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。</p>
<p>一次HTTP操作称为一个<strong>事务</strong>，其工作过程可分为四步：</p>
<p>1）首先客户机与服务器需要<strong>建立连接</strong>。只要单击某个超级链接，HTTP的工作开始。</p>
<p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：<strong>统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</strong></p>
<p>3）服务器接到请求后，给予相应的响应信息，其格式为一个<strong>状态行，</strong>包括<strong>信息的协议版本号</strong>、<strong>一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容</strong>。</p>
<p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<p>//① 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过<strong>TCP</strong> 来完成的，一般 TCP 连接的端口号是<strong>80</strong>。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：<strong>统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容</strong>。</p>
<p>② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>
<p>②HTTPS</p>
<p><img src="https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的<strong>证书</strong>。</p>
<p>③客户端利用服务器传过来的信息<strong>验证服务器的合法性</strong>，服务器的合法性包括：1）证书是否过期 2）发行服务器证书的CA 是否可靠  3）发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”  4）服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p>
<p>④用户端随机产生一个用于通讯的“<strong>对称密码”</strong>，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的<strong>“预主密码”</strong>传给服务器。</p>
<p>⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个<strong>随机数</strong>然后对其进行<strong>数据签名</strong>，将这个含有<em>签名的随机数和*</em>客户自己的证书*<em>以及</em>加密过的“预主密码*”一起传给服务器。</p>
<p>⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>
<p>⑦服务器和客户端用相同的主密码即“<strong>通话密码</strong>”，一个对称密钥用于<strong>SSL 协议</strong>的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>⑩SSL 的握手部分结束，<strong>SSL 安全通道</strong>的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<p>//简版</p>
<p>① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</p>
<p>② 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</p>
<p>③ 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 <strong>pre_master_secret</strong> 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；</p>
<p>④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出<strong>加密和 MAC密钥</strong>（参考 DH密钥交换算法） ；</p>
<p>⑤ 客户端将所有握手消息的 MAC 值发送给服务器；</p>
<p>⑥ 服务器将所有握手消息的 MAC 值发送给客户端。</p>
<p>//<strong>SSL建立连接过程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190803111825690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1.client向server发送请求<a href="https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。" target="_blank" rel="noopener">https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。</a><br>2.server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。<br>3.随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。<br>4.客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。<br>5.客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。<br>6.传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。<br>7.服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。<br>8.客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。<br>9.同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。</p>
<h4 id="1-怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？"><a href="#1-怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？" class="headerlink" title="1.怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？"></a><strong>1.怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？</strong></h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdn.net/20180724090424143?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></h4><h4 id="2-证书如何安全传输，被掉包了怎么办？"><a href="#2-证书如何安全传输，被掉包了怎么办？" class="headerlink" title="2.证书如何安全传输，被掉包了怎么办？"></a><strong>2.证书如何安全传输，被掉包了怎么办？</strong></h4><p><img src="https://img-blog.csdn.net/20180719095555854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="身份认证"></p>
<h4 id="数字证书内容"><a href="#数字证书内容" class="headerlink" title="数字证书内容"></a>数字证书内容</h4><p>包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。</p>
<h4 id="验证证书安全性过程"><a href="#验证证书安全性过程" class="headerlink" title="验证证书安全性过程"></a>验证证书安全性过程</h4><p>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。<br>然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。</p>
<h4 id="那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）"><a href="#那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）" class="headerlink" title="那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）"></a>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）</h4><p>显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。</p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><h4 id="SSL提供服务"><a href="#SSL提供服务" class="headerlink" title="SSL提供服务"></a><strong><em>SSL提供服务</em></strong></h4><p>(1)认证用户和服务器，确保数据发送到正确的<a href="https://baike.baidu.com/item/客户机" target="_blank" rel="noopener">客户机</a>和<a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a>；</p>
<p>(2)加密数据以防止数据中途被窃取；</p>
<p> (3)维护数据的完整性，确保数据在传输过程中不被改变</p>
<h4 id="SSL工作流程"><a href="#SSL工作流程" class="headerlink" title="SSL工作流程"></a><strong><em>SSL工作流程</em></strong></h4><p>1)客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</p>
<p>(2)服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含<strong>生成</strong>主密钥所需的<strong>信息；</strong></p>
<p>(3)客户根据收到的服务器响应信息，产生一个<strong>主密钥</strong>，并用服务器的<strong>公开密钥加密后传给服务器</strong>；</p>
<p>(4)服务器回复该主密钥，并返回给客户一个<strong>用主密钥认证的信息</strong>，以此让客户认证服务器。</p>
<p><strong><a href="https://baike.baidu.com/item/用户认证" target="_blank" rel="noopener">*用户认证*</a>阶段</strong></p>
<p>在此之前，服务器已经通过了<a href="https://baike.baidu.com/item/客户认证" target="_blank" rel="noopener">客户认证</a>，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其<a href="https://baike.baidu.com/item/公开密钥" target="_blank" rel="noopener">公开密钥</a>，从而向服务器提供认证。</p>
<h4 id="SSL协议提供的安全通道有以下三个特性："><a href="#SSL协议提供的安全通道有以下三个特性：" class="headerlink" title="SSL协议提供的安全通道有以下三个特性："></a>SSL协议提供的安全通道有以下三个特性：</h4><p><strong>机密性：</strong>SSL协议使用<strong>密钥</strong>加密通信数据。</p>
<p><strong>可靠性：</strong>服务器和客户都会被认证，客户的认证是可选的。</p>
<p><strong>完整性：</strong>SSL协议会对传送的数据进行完整性检查</p>
<p>服务器证书(server certificates)是SSL数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成Web服务器的SSL安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户 提供验证您Web站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>
<h2 id="四、HTTP与HTTPS区别"><a href="#四、HTTP与HTTPS区别" class="headerlink" title="四、HTTP与HTTPS区别"></a>四、HTTP与HTTPS区别</h2><p>1、https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的。Https协议是由<strong>SSL+Http协议</strong>构建的可进行加密传输、身份认证的网络协议，比http协议安全。(区别：无状态与无连接：无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<h2 id="五、HTTPS相对HTTP的改进"><a href="#五、HTTPS相对HTTP的改进" class="headerlink" title="五、HTTPS相对HTTP的改进"></a>五、HTTPS相对HTTP的改进</h2><p><strong>双向的身份认证</strong></p>
<p>客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。</p>
<p>具体过程如下：</p>
<p>客户端发起 SSL 握手消息给服务端要求连接。</p>
<p>服务端将证书发送给客户端。</p>
<p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p>
<p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p>
<p><strong>数据传输的机密性</strong></p>
<p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是<a href="https://baike.baidu.com/item/RSA/210678" target="_blank" rel="noopener">RSA</a>), 数据签名摘要算法 ( 一般是<a href="https://baike.baidu.com/item/SHA/9533316" target="_blank" rel="noopener">SHA</a>或者<a href="https://baike.baidu.com/item/MD5/212708" target="_blank" rel="noopener">MD5</a>) , 加密传输数据的对称加密算法 ( 一般是<a href="https://baike.baidu.com/item/DES/210508" target="_blank" rel="noopener">DES</a>),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密</p>
<p><strong>防止重放攻击</strong></p>
<p>SSL使用<strong>序列号</strong>来保护通讯方免受报文重放攻击。</p>
<p>这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个<strong>唯一的随机数</strong>来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。</p>
<p>可以看到，鉴于电子商务等安全上的需求，Https对比Http协议，在安全方面已经取得了极大的增强。</p>
<p>总结来说，Https的改进点在于创造性的使用了<strong>非对称加密算法</strong>，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了<a href="https://baike.baidu.com/item/非对称加密/9874417" target="_blank" rel="noopener">非对称加密</a>的安全性和<a href="https://baike.baidu.com/item/对称加密/2152944" target="_blank" rel="noopener">对称加密</a>的快速性。</p>
<h2 id="六、Https-优点"><a href="#六、Https-优点" class="headerlink" title="六、Https 优点"></a>六、Https 优点</h2><p>1.使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<p>2.Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p>
<p>3.Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<h2 id="七、对比、应用"><a href="#七、对比、应用" class="headerlink" title="七、对比、应用"></a>七、对比、应用</h2><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>1）Https协议的<strong>安全是有范围的</strong>。在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>
<p>2）Https协议的<strong>加密范围也比较有限</strong>。最关键的，<strong>SSL证书的信用链体系</strong>并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<blockquote>
<p>中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。</p>
</blockquote>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p>1.SSL证书需要购买申请，功能越强大的证书费用越高。</p>
<p>2.SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</p>
<p>（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p>
<p>3.根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</p>
<p>4.HTTPS连接缓存不如HTTP高效，流量成本高。</p>
<p>5.HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</p>
<p>6.HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。</p>
<p>比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2019/10/26/%E4%BD%BF%E7%94%A8Github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" >
  使用Github和Hexo搭建自己的博客
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2019/10/26/%E4%BD%BF%E7%94%A8Github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"><span class="article-date">
  2019-10-26
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <h1 id="使用Github和Hexo搭建自己的博客"><a href="#使用Github和Hexo搭建自己的博客" class="headerlink" title="使用Github和Hexo搭建自己的博客"></a>使用Github和Hexo搭建自己的博客</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>这是一篇关于如何使用 Github Pages 和 Hexo 搭建小白独立博客的文章。里面有一些博主遇到的小问题，只要踏踏实实跟着教程走，自己的博客就在向你挥挥手哦！Github Pages可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>此文章参考：<a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/82121420</a></p>
<h2 id="二、下载NODE-GIT-HEXO"><a href="#二、下载NODE-GIT-HEXO" class="headerlink" title="二、下载NODE+GIT+HEXO"></a>二、下载NODE+GIT+HEXO</h2><h3 id="（1）下载node-js"><a href="#（1）下载node-js" class="headerlink" title="（1）下载node.js"></a>（1）下载node.js</h3><p>官网下载网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> ，根据自己情况选择版本，默认设置即可。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY0ODFkMzc0MC5wbmc" alt="img"></p>
<h3 id="（2）下载Git"><a href="#（2）下载Git" class="headerlink" title="（2）下载Git"></a>（2）下载Git</h3><p>下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a> 默认下载。</p>
<p>检验Git是否安装成功：</p>
<p>（1）打开cmd，输入以下指令，有相应版本信息显示即安装成功。</p>
<p><code>git --version</code></p>
<p><code>node -v</code></p>
<p><code>npm -v</code></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY0ZWU4YTc5NC5wbmc" alt="img"></p>
<p>（2）若安装成功，在桌面右键鼠标，可以看到菜单多了Git GUI Here 和 Git Bash Here两个选项。第一个是图形界面的Git操作，第二个是命令行。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1MGVjMjA5Mi5wbmc" alt="img"></p>
<h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="(3)安装Hexo"></a>(3)安装Hexo</h3><p>（1）选择一个磁盘，新建一个文件夹，自己重命名文件夹（如：我的文件夹为：Ｅ\KIKICHUANG-Q_Blog），博客相关文件将储存在此文件夹下。</p>
<p>（2）在该文件夹下右键鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装。</p>
<p>第一个命令表示安装 hexo，第二个命令表示安装 hexo 部署到 git page 的 deployer，如图所示即为安装成功。</p>
<p><code>npm install hexo-cli -g  
npm install hexo-deployer-git --save</code> </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1M2Q0YjAxOS5wbmc" alt="img"></p>
<p>（3）初始化Hexo</p>
<p>在刚才新建的文件夹里面再次新建一个 Hexo 文件夹（如：我的文件夹为：E\TRHX_Blog\Hexo）,进入该 Hexo 文件夹右键鼠标，点击 Git Bash Here，输入以下命令，如图所示则安装成功。</p>
<p><code>hexo init</code></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1NjZiNGI2Yi5wbmc" alt="img"></p>
<p>（4）检查</p>
<p>Hexo安装完成后，将会在指定文件夹中新建所需要的文件，Hexo 文件夹下的目录如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1OGQyZWVlNS5wbmc" alt="img"></p>
<h2 id="三、本地查看效果"><a href="#三、本地查看效果" class="headerlink" title="三、本地查看效果"></a>三、本地查看效果</h2><p>执行以下命令，执行完即可登录 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看效果</p>
<p><code>hexo generate  
hexo server</code> </p>
<p>显示以下说明成功：</p>
<p> <code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>
<p>登录 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看效果：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1YjdjNzRkMi5wbmc" alt="img"></p>
<h2 id="四、将博客部署到GIthub-Pages上"><a href="#四、将博客部署到GIthub-Pages上" class="headerlink" title="四、将博客部署到GIthub Pages上"></a>四、将博客部署到GIthub Pages上</h2><p>我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上。</p>
<h3 id="（1）注册Github账户"><a href="#（1）注册Github账户" class="headerlink" title="（1）注册Github账户"></a>（1）注册Github账户</h3><p>官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p>
<p>点击sign up注册</p>
<h3 id="（2）创建项目代码库"><a href="#（2）创建项目代码库" class="headerlink" title="（2）创建项目代码库"></a>（2）创建项目代码库</h3><p>点击 New repository 开始创建，步骤及注意事项见下图：<strong>（万分注意：一定要以 ”你的用户名.github.io”格式命名！博主当时漏了.io导致不匹配，网站404，重新再在这一步修改了回来才解决，所以千万记得格式严谨！！！！！!）</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1ZTA5MzBjMi5wbmc" alt="img"></p>
<h3 id="（3）配置SSH密钥"><a href="#（3）配置SSH密钥" class="headerlink" title="（3）配置SSH密钥"></a>（3）配置SSH密钥</h3><p>在你第一次新建的文件夹里面（如：我的文件夹为：Ｅ\KIKICHUANG-Q_Blog） Git Bash Here 输入以下命令：</p>
<p><code>ssh-keygen -t rsa -C &quot;your email@example.com&quot;</code><br><code>//引号里面填写你的邮箱地址，比如我的是903822154@qq.com</code></p>
<p>之后会出现：</p>
<p> <code>Generating public/private rsa key pair.  
Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):  
//到这里可以直接回车将密钥按默认文件进行存储</code></p>
<p>然后：</p>
<p><code>Enter passphrase (empty for no passphrase):</code><br>//这里是要你输入密码，其实不需要输什么密码，直接回车就行<br><code>Enter same passphrase again:</code>  </p>
<p>//再回车</p>
<p>接下来会显示：</p>
<p> <code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.  
Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.  
The key fingerprint is:</code><br>这里是各种字母数字组成的字符串，结尾是你的邮箱<br><code>The key&#39;s randomart image is:</code><br>这里也是各种字母数字符号组成的字符串  </p>
<p>运行下列命令：（将公钥的内容复制到系统粘贴板上）</p>
<p> <code>clip &lt; ~/.ssh/id_rsa.pub</code></p>
<h3 id="5-在Github账户添加你的公钥"><a href="#5-在Github账户添加你的公钥" class="headerlink" title="(5)在Github账户添加你的公钥"></a>(5)在Github账户添加你的公钥</h3><p>（1） 登陆 GitHub，进入 Settings：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2MDZlNzU1OC5wbmc" alt="img"></p>
<p>（2)点击 SSH and GPG Keys：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2MjJiNDU4OC5wbmc" alt="img"></p>
<p>(3)选择 New SSH key：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2M2ViMWFiMi5wbmc" alt="img"></p>
<p>(4)粘贴密钥：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2YmMxZmM4Ny5wbmc" alt="img"></p>
<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="(5)测试"></a>(5)测试</h3><p>输入以下命令：注意：<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>不要做任何更改！</p>
<p><code>ssh -T git@github.com</code></p>
<p>之后：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2ZTNiNDgwMy5wbmc" alt="img"></p>
<p>YES之后：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3MDJjNDZkNi5wbmc" alt="img"></p>
<p>则OK！</p>
<h3 id="（6）配置-Git-个人信息"><a href="#（6）配置-Git-个人信息" class="headerlink" title="（6）配置 Git 个人信息"></a>（6）配置 Git 个人信息</h3><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"此处填你的用户名"</span>  </span><br><span class="line">git config --global user.email  <span class="string">"此处填你的邮箱"</span></span><br></pre></td></tr></table></figure>

<p>OK!！ Key 配置成功，本机已成功连接到 Github！</p>
<h2 id="五、将本地的-Hexo-文件更新到-Github-的库中"><a href="#五、将本地的-Hexo-文件更新到-Github-的库中" class="headerlink" title="五、将本地的 Hexo 文件更新到 Github 的库中"></a>五、将本地的 Hexo 文件更新到 Github 的库中</h2><p>① 登录 Github 打开自己的项目 your name.github.io</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3MjBjY2FlMC5wbmc" alt="img"></p>
<p>② 鼠标移到 Clone or download 按钮，选择Use SSH<img src="https://img-blog.csdnimg.cn/20190816220246218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p>③ 一键复制地址<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3NmNiM2RhNC5wbmc" alt="img"></p>
<p>④ 打开你创建的 Hexo 文件夹（如：E:\KIKICHUANG-Q\Hexo），右键用记事本（Notepad++或者VS code等都可以）打开该文件夹下的 _config.yml 文件</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3OGI4YmEzZS5wbmc" alt="img"></p>
<p><strong>⑤ 按下图修改 _config.yml 文件并保存</strong></p>
<p>这一步很关键！！！！！！！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3ZTExZWVkNy5wbmc" alt="img"></p>
<p> <strong><em>保险起见可以复制以下的成功代码：</em></strong></p>
<p>deploy:<br>  type: git<br>  repository:<br>  branch: master</p>
<p>⑥ 在 Hexo 文件夹下分别执行以下命令</p>
<p> <code>hexo g</code></p>
<p><code>hexo d</code></p>
<p>//或者直接</p>
<p><code>hexo g -d</code></p>
<p>执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功。</p>
<p><code>ERROR Deployer not found: git</code></p>
<p>需要执行以下命令再安装一次：</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>再执行 ：</p>
<p><code>hexo g</code></p>
<p><code>hexo d</code></p>
<p>你的博客就会部署到 Github 上了。</p>
<p>⑦ 访问博客</p>
<p>你的博客地址<strong>：https://你的用户名.github.io，</strong>比如我的是：<a href="https://KIKICHUANG-Q.github.io,现在每个人都可以通过此链接访问你的博客了。" target="_blank" rel="noopener">https://KIKICHUANG-Q.github.io,现在每个人都可以通过此链接访问你的博客了。</a></p>
<h2 id="六、在博客上发表文章"><a href="#六、在博客上发表文章" class="headerlink" title="六、在博客上发表文章"></a>六、在博客上发表文章</h2><p>（1）新建一个空文章，输入以下命令，会在项目 \Hexo\source_posts 中生成 文章标题.md 文件，文章标题根据需要命名</p>
<p><code>hexo n &quot;文章标题&quot;</code></p>
<p>//或者：</p>
<p>直接在 <strong>\Hexo\source_posts</strong> 目录下右键鼠标新建文本文档，<strong>改后缀为 .md</strong> 即可，这种方法比较方便（推荐）</p>
<p>（1）用编辑器编写文章</p>
<p>md 全称 Markdown， Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会， <strong>.md 文件</strong>以使用支持 Markdown 语法的编辑器编辑，然后<strong>保存文件到 \Hexo\source_posts 文件夹下</strong>即可。</p>
<p>（3）当我们用编辑器写好文章后，可以使用以下命令将其推送到服务器上。</p>
<p><code>hexo g</code></p>
<p><code>hexo d</code></p>
<p>//或者</p>
<p><code>hexo d -g</code></p>
<h3 id="Last：OKKK！现在访问你的专属博客即可见你写的文章啦！！！"><a href="#Last：OKKK！现在访问你的专属博客即可见你写的文章啦！！！" class="headerlink" title="Last：OKKK！现在访问你的专属博客即可见你写的文章啦！！！"></a>Last：OKKK！现在访问你的<strong>专属博客</strong>即可见你写的文章啦！！！</h3><h2 id="七、美化"><a href="#七、美化" class="headerlink" title="七、美化"></a>七、美化</h2><p>如果想让你的博客更加special的话，你可以登录Hexo官网，选择自己喜爱的主题进行更换，接下来就是慢慢码字学习的过程啦！</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2019/10/25/hello-world/" >
  Hello World
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2019/10/25/hello-world/"><span class="article-date">
  2019-10-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

        
      </div>
    </div>

  






          <div class="main-footer">
  
    © 2020 Hexo - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
